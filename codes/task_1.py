def f(n):
    n = bin(n)[2:] # создаётся двочиная запись (при помощи среза избавляемся от префикса)
    
    if (len(n) % 2 == 0): # проверяем на чётность/нечётность кол-ва элементов (аналог длине)
        left = n[:len(n) // 2] # левая половина - это всё, что идёт до середины
        right = n[len(n) // 2:] # правая половина - это всё после середины
        # пример: 110_001
        # len(n) // 2 = 3
        # так как правая граница среза не включительна, то в left присвоится 110, тогда в right - 001
        n = right + left # конкатенация строк
    else:
        afterZero = '' # объявим переменную, в которой будем хранить элементы, стоящие за '0'
        for i in range(len(n) - 1): # итерируемся по каждому символу строки (-1, поскольку работаем со следующим элементом.
                                    # иными словами, чтобы не вылететь за границы массива)
            if (n[i] == '0'): # если текущий элемент - это '0':
                afterZero += n[i + 1] # тогда в соответствующую переменную добавляем следующий элемент

        n += afterZero # после цикла добавляем всё, что нашли

    result = int(n, 2) # наш результат - десятичное число
    return result

for n in range(1, 700): # по условию число N натуральное, тогда начнём с 1 и до какого-нибудь большого числа
    if (f(n) == 44): # проверка, что результат равен 44
        print(n)
        break # остановка цикла (минимальное N найдено)





